<!DOCTYPE html>
<meta charset="utf-8">
<style>

    body {
        margin: 0;
    }

    path.topo {
        fill: none;
        stroke: red;
        stroke-linejoin: round;
        stroke-width: 1.5px;
    }

</style>
<svg></svg>
<script src="d3.v4.min.js"></script>
<script src="d3-tile.v0.0.min.js"></script>
<script src="topojson.v1.min.js"></script>
<script src="d3-hexbin.v0.2.min.js"></script>
<script>

    var pi = Math.PI,
        tau = 2 * pi;

    var width = Math.max(960, window.innerWidth),
        height = Math.max(500, window.innerHeight);

    // Initialize the projection to fit the world in a 1Ã—1 square centered at the origin.
    var projection = d3.geoMercator()
        .scale(1 / tau)
        .translate([0, 0]);

    var path = d3.geoPath()
        .projection(projection);

    var tile = d3.tile()
        .size([width, height]);

    var zoom = d3.zoom()
        .scaleExtent([1 << 11, 1 << 20])
        .on("zoom", zoomed);

    var svg = d3.select("svg")
        .attr("width", width)
        .attr("height", height);

    var raster = svg.append("g");

    var vector = svg.append("path");
    var vector2 = svg.append("g");
    var vector3 = svg.append("g");

    var d = [
        [-98.5, 39.5],
        [-98.5-0.3*1, 39.5-0.3*1],
        [-98.5-0.3*2, 39.5-0.3*1],
        [-98.5-0.3*1, 39.5-0.3*2],
        [-98.5-0.3*3, 39.5-0.3*1],
        [-98.5-0.3*1, 39.5-0.3*4],
        [-98.5-0.3*4, 39.5-0.3*1],
        [-98.5-0.3*1, 39.5-0.3*1],
        [-98.5-0.3*5, 39.5-0.3*1],
        [-98.5-0.3*1, 39.5-0.3*6],
        [-98.5-0.3*1, 39.5-0.3*1],
    ];

    d3.json("us.json", function(error, us) {
        if (error) throw error;

        // Compute the projected initial center.
        var center = projection([-98.5, 39.5]);

        // Apply a zoom transform equivalent to projection.{scale,translate,center}.
        svg
            .call(zoom)
            .call(zoom.transform, d3.zoomIdentity
                .translate(width / 2, height / 2)
                .scale(1 << 14)
                .translate(-center[0], -center[1]));

        // vector
        //     .attr("class", "topo")
        //     .attr("d", path(topojson.mesh(us, us.objects.counties)));

        vector2.selectAll(".symbol")
            .data(d)
            .enter()
            .append("g")
            .attr("transform", function(d) {
                var coords = projection([d[0], d[1]]);
                return "translate(" + coords[0] + "," + coords[1] + ")";
            })
            .append("circle")
            .attr("class", "sym")
            .attr("r", 0.001)
            .attr("cx", 0)
            .attr("cy", 0)
            .attr("fill-opacity", "0.3")
            .style("fill", "blue");

        var boxesRaw = [];
        d.forEach((box, index) => {
            boxesRaw.push(projection([box[0], box[1]]));
        });

        console.log(boxesRaw.length);

        var hexbin = d3.hexbin()
            .radius(0.001)
            .extent([[0, 0], [width, height]]);

        var hbins = hexbin(boxesRaw);

        console.log(hbins.length);

        hbins.sort(function(a, b){
            return a.length - b.length;
        });

        var percentage_cutoff = (hbins.length/100) * 1,
            hbins_minmaxcutoff = hbins.slice(percentage_cutoff, hbins.length-percentage_cutoff);

        var color = d3.scaleSequential(d3.interpolateViridis)
            .domain(d3.extent(hbins_minmaxcutoff, function(d) { return d.length; }));

        vector3
            .attr("class", "layer_hex")
            .append("g")
            .attr("class", "hexagon")
            // .attr("clip-path", "url(#clip)")
            .selectAll("path")
            .data(hbins)
            .enter().append("path")
            .attr("d", hexbin.hexagon())
            .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
            .attr("fill", function(d) { return color(d.length); });
    });

    function zoomed() {
        var transform = d3.event.transform;

        var tiles = tile
            .scale(transform.k)
            .translate([transform.x, transform.y])
            ();

        vector
            .attr("transform", transform)
            .style("stroke-width", 1 / transform.k);

        vector2
            .attr("transform", transform)
            .style("stroke-width", 1 / transform.k);

        vector3
            .attr("transform", transform);

        var image = raster
            .attr("transform", stringify(tiles.scale, tiles.translate))
            .selectAll("image")
            .data(tiles, function(d) { return d; });

        image.exit().remove();

        image.enter().append("image")
            .attr("xlink:href", function(d) { return "http://" + "abc"[d[1] % 3] + ".tile.openstreetmap.org/" + d[2] + "/" + d[0] + "/" + d[1] + ".png"; })
            .attr("x", function(d) { return d[0] * 256; })
            .attr("y", function(d) { return d[1] * 256; })
            .attr("width", 256)
            .attr("height", 256);
    }

    function stringify(scale, translate) {
        var k = scale / 256, r = scale % 1 ? Number : Math.round;
        return "translate(" + r(translate[0] * scale) + "," + r(translate[1] * scale) + ") scale(" + k + ")";
    }

</script>