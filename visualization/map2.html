<!DOCTYPE html>
<meta charset="utf-8">
<style>

</style>
<svg width="900" height="600">
    
     <filter id="grayscale">
          <feColorMatrix type="saturate" values="0"/>
    </filter>

</svg>
<script src="d3.v4.min.js"></script>
<script src="d3-tile.v0.0.min.js"></script>
<script src="d3-hexbin.v0.2.min.js"></script>
<script>

var pi = Math.PI,
    tau = 2 * pi;

var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height")
    // margin = {top: 20, right: 20, bottom: 30, left: 40},
    // g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    g_map = svg.append("g");
    g_hex = svg.append("g");

var projection = d3.geoMercator()
    .scale((1 << 8 + 19) / tau)
    .translate([width / 2, height / 2])
    .center([11.037630, 50.971296]);

var path = d3.geoPath()
    .projection(projection);

var color = d3.scaleSequential(d3.interpolateLab("white", "steelblue"))
    .domain([0, 50]);

var alpha = d3.scaleLinear()
    .domain([0, 50])
    .range([0.2, 1.0]);

var hexbin = d3.hexbin()
    .radius(5)
    .extent([[0, 0], [width, height]]);

d3.text("boxes_warped.txt", function(error, raw) {
    if (error) throw error;

    var boxes = d3.dsvFormat(" ").parseRows(raw);
        boxes.forEach((box, index) => {
            return boxes[index] = projection([box[1], box[0]]); // lonlat!
        });

    console.log(boxes[0])

    var tiles = d3.tile()
        .size([width, height])
        .scale(projection.scale() * tau)
        .translate(projection([0, 0]))
        ();

    g_map.append("g")
        .selectAll("image")
        .data(tiles)
    .enter().append("image")
        .attr("xlink:href", getImg)
        .attr("filter", "url(#grayscale)")
        .attr("x", function(d) { 
            // console.log("d: " + d[0]); 
            // console.log("tiles.translate: " + tiles.translate[0]); 
            return (d[0] + tiles.translate[0]) * tiles.scale; 
        })
        .attr("y", function(d) { return (d[1] + tiles.translate[1]) * tiles.scale; })
        .attr("width", tiles.scale)
        .attr("height", tiles.scale);

    g_hex.append("g")
            .attr("class", "hexagon")
            .attr("clip-path", "url(#clip)")
        .selectAll("path")
        .data(hexbin(boxes))
        .enter().append("path")
            .attr("d", hexbin.hexagon())
            .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
            .attr("fill", function(d) { return color(d.length); })
            .attr("fill-opacity", function(d) { return alpha(d.length); });

    // svg.selectAll(".dot")
    //         .data(boxes)
    // .enter().append("circle")
    //     .attr("class", "dot")
    //     .attr("r", 2)
    //     .attr("cx", function(d) { return d[0]; })
    //     .attr("cy", function(d) { return d[1]; })
    //     .attr("fill-opacity", "0.05")
    //     .style("fill", "black");

});

function getImg(d) {

    console.log(d[2]);

    var tilename = d[2] + "/" + d[0] + "/" + d[1] + ".png";
        url = "http://" + "abc"[d[1] % 3] + ".tile.openstreetmap.org/" + tilename;
    return url;
}

</script>
